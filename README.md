

# Backend Developer Test

Production-grade AWS serverless project demonstrating S3 file operations and an OpenAPI-driven API Gateway + Lambda pipeline, fully defined as Infrastructure as Code with AWS CDK and runnable locally via LocalStack.

## Architecture

```mermaid
graph TD
    subgraph Exercise 1
        CLI_UP[Upload Script] -->|PutObject| S3[(S3 Bucket<br/>versioned + encrypted)]
        CLI_DL[Retrieve Script] -->|GetObject| S3
    end

    subgraph Exercise 2 — Local Dev
        SPEC_L[openapi.yaml] -->|BucketDeployment| S3
        SPEC_L -->|SpecRestApi inline| APIGW[API Gateway<br/>REST API]
        APIGW -->|POST /items| LAMBDA[Lambda<br/>create-item]
        LAMBDA -->|PutObject| S3
    end

    subgraph Exercise 2 — Production CI/CD
        GIT[Push to main] -->|triggers| GHA[GitHub Action]
        GHA -->|1. Upload spec| S3
        GHA -->|2. put-rest-api| APIGW2[API Gateway]
        GHA -->|3. create-deployment| APIGW2
    end

    subgraph Infrastructure
        CDK[AWS CDK v2] --> StorageStack
        CDK --> ApiStack
        StorageStack --> S3
        ApiStack --> APIGW
        ApiStack --> LAMBDA
    end
```

## Prerequisites

| Tool | Version | Install |
|------|---------|---------|
| Node.js | 20.x+ | [nodejs.org](https://nodejs.org) |
| Docker | Latest | [docker.com](https://www.docker.com) |
| AWS CDK | 2.x | `npm install -g aws-cdk` |
| cdklocal | Latest | `npm install -g aws-cdk-local` |
| awslocal | Latest | `pip install awscli-local` |

## Quick Start

```bash
# 1. Install dependencies
npm install

# 2. Start LocalStack
npm run local:up

# 3. Deploy CDK stacks to LocalStack
npm run local:deploy
# Note the ApiStack outputs — you'll need the API URL for Exercise 2:
#   ApiStack.ApiUrl = https://<api-id>.execute-api.localhost.localstack.cloud:4566/v1/

# 4. Run Exercise 1 — upload & retrieve
npm run upload
npm run retrieve

# 5. Run Exercise 2 — call the POST endpoint
# Use the ApiUrl from the deploy output above:
curl -s -X POST https://<api-id>.execute-api.localhost.localstack.cloud:4566/v1/items \
  -H 'Content-Type: application/json' \
  -d '{"name": "My Item", "description": "Created via API"}'
```

## Exercise 1: S3 Upload & Retrieve

### Upload a JSON file

```bash
# Upload the default sample file
npm run upload

# Upload a specific file with a custom key
npm run upload -- path/to/file.json my-folder/my-key.json
```

### Retrieve a JSON file

```bash
# Retrieve the default key
npm run retrieve

# Retrieve a specific key
npm run retrieve -- my-folder/my-key.json
```

### Error handling

Both scripts handle these scenarios with structured error output:
- **NoSuchBucket** — bucket doesn't exist
- **NoSuchKey** — object key not found
- **AccessDenied** — insufficient IAM permissions
- **Invalid JSON** — file content is not valid JSON
- **Network/throttle errors** — classified as retryable

## Exercise 2: API Gateway POST Endpoint

The OpenAPI spec (`api/openapi.yaml`) is the single source of truth for the API contract. The Lambda handler persists each created item to S3 under the `items/` prefix.

### Local development (LocalStack)

For local development, CDK reads the spec, substitutes the Lambda ARN, uploads it to S3 via `BucketDeployment`, and imports it inline into API Gateway via `SpecRestApi`. Inline import is used locally because CloudFormation must resolve the Lambda ARN token at deploy time, and LocalStack doesn't support `Custom::CDKBucketDeployment` for the S3-to-API Gateway flow.

### Production CI/CD (GitHub Actions)

In production, the full Swagger-to-API-Gateway flow runs via a GitHub Action (`.github/workflows/deploy-swagger.yml`):

1. **Trigger** — push to `main` that modifies `api/openapi.yaml`
2. **Substitute** — replaces the `${CreateItemFunctionArn}` placeholder with the real Lambda ARN
3. **Upload to S3** — uploads the resolved spec to the storage bucket under `api-specs/`
4. **Import from S3** — calls `aws apigateway put-rest-api` to import the spec from S3 into API Gateway
5. **Deploy** — creates a new API Gateway deployment to stage `v1`

This implements the requirement as written: **Swagger → S3 → API Gateway imports from S3**.

To use the GitHub Action, add the `AWS_ROLE_ARN` secret to your repository (an IAM role with permissions for S3, API Gateway, Lambda, and CloudFormation read access).

### Finding your API URL

After `npm run local:deploy`, the API URL is printed in the stack outputs:

```
ApiStack.ApiUrl = https://<api-id>.execute-api.localhost.localstack.cloud:4566/v1/
```

Copy the full URL — the `<api-id>` is randomly generated by LocalStack on each deploy.

### Create an item

```bash
# Replace the URL with your actual ApiStack.ApiUrl output
curl -s -X POST https://<api-id>.execute-api.localhost.localstack.cloud:4566/v1/items \
  -H 'Content-Type: application/json' \
  -d '{"name": "Widget", "description": "A useful widget"}'
```

**201 Response:**
```json
{
  "id": "550e8400-e29b-41d4-a716-446655440000",
  "name": "Widget",
  "description": "A useful widget",
  "createdAt": "2026-02-15T10:30:00.000Z"
}
```

**400 Response (validation error):**
```json
{
  "error": "VALIDATION_ERROR",
  "message": "name is required and must be a non-empty string",
  "requestId": "abc-123"
}
```

**400 Response (invalid JSON):**
```json
{
  "error": "INVALID_JSON",
  "message": "Request body is not valid JSON",
  "requestId": "abc-123"
}
```

## IAM Permissions

| Principal | Permission | Resource | Why |
|-----------|-----------|----------|-----|
| `create-item` Lambda | `s3:GetObject`, `s3:PutObject`, `s3:DeleteObject`, `s3:GetBucket*` | Storage bucket + objects | Read/write items to S3. Granted via `bucket.grantReadWrite(fn)` which generates a scoped policy. |
| API Gateway | `lambda:InvokeFunction` | `create-item` Lambda ARN | API Gateway needs permission to invoke the Lambda on incoming HTTP requests. Scoped to this API's execution ARN. |
| Lambda execution role | `logs:CreateLogGroup`, `logs:CreateLogStream`, `logs:PutLogEvents` | CloudWatch Logs | Auto-granted by CDK's `NodejsFunction`. Enables structured logging. |
| Lambda execution role | `xray:PutTraceSegments`, `xray:PutTelemetryRecords` | `*` | Auto-granted when `tracing: ACTIVE`. Enables X-Ray distributed tracing. |

All IAM policies are generated by CDK grants — no raw policy JSON in the codebase.

## Testing

```bash
# Unit tests (mocked AWS SDK)
npm run test

# Unit tests with coverage report
npm run test:coverage

# Integration tests (requires LocalStack running)
npm run test:int
```

### Test structure

```
test/
├── setup.ts                              # Global test setup
├── helpers/
│   └── api-gateway-event.ts              # API Gateway event factory
├── unit/
│   ├── handlers/
│   │   └── create-item.test.ts           # Lambda handler tests
│   └── lib/
│       ├── errors.test.ts                # Error classification tests
│       └── s3-client.test.ts             # S3 client factory tests
└── integration/
    ├── setup.ts                          # LocalStack client + bucket setup
    ├── s3-upload-retrieve.test.ts        # End-to-end S3 operations
    └── api-pipeline.test.ts             # API Gateway → Lambda → S3 pipeline tests
```

## Deploying to AWS

The same CDK stacks that run locally via LocalStack can be deployed to a real AWS account with no code changes. The S3 client factory, Lambda handler, and CDK stacks all detect the environment automatically.

```bash
# 1. Configure AWS credentials
aws configure

# 2. Bootstrap CDK (one-time per account/region)
npx cdk bootstrap

# 3. Deploy all stacks
npm run cdk:deploy
```

The `StorageStack` creates a versioned, encrypted S3 bucket with public access blocked. The `ApiStack` deploys the Lambda and API Gateway — the API URL is printed in the stack outputs.

To tear down:

```bash
npx cdk destroy --all
```

## Design Decisions

| Decision | Rationale |
|----------|-----------|
| **AWS CDK over raw CloudFormation** | TypeScript-native, type-safe constructs, `NodejsFunction` handles esbuild bundling automatically |
| **LocalStack for local dev** | Fast feedback loop, no AWS costs during development, reproducible via Docker Compose |
| **Vitest over Jest** | Faster execution, native ESM/TypeScript support, same API surface, compatible with `aws-sdk-client-mock` |
| **OpenAPI spec as source of truth** | Single contract for API Gateway + documentation; `x-amazon-apigateway-integration` extensions make it directly deployable |
| **S3 client factory pattern** | Centralizes LocalStack detection, enables connection reuse via module-scope caching, simplifies testing |
| **Typed error classification** | Distinguishes retryable vs terminal AWS errors, prevents leaking internal details to API consumers |
| **ARM64 (Graviton2) Lambdas** | Better price-performance than x86_64 |
| **CloudFormation auto-discovery for bucket name** | The bucket name is generated by CloudFormation at deploy time; the scripts query the stack outputs so the user doesn't need to copy-paste it |

## Cleanup

```bash
# Tear down CDK stacks
npm run local:destroy

# Stop LocalStack
npm run local:down

# Full reset (stop, clear volumes, restart, redeploy)
npm run local:reset
```

## Project Structure

```
├── .github/workflows/
│   └── deploy-swagger.yml           # CI/CD: Swagger → S3 → API Gateway
├── bin/app.ts                        # CDK app entry point
├── lib/
│   ├── stacks/
│   │   ├── storage-stack.ts          # S3 bucket (versioned, encrypted)
│   │   └── api-stack.ts              # API Gateway + Lambda + OpenAPI import
│   └── constructs/
│       └── lambda-function.ts        # Reusable Lambda construct
├── src/
│   ├── handlers/create-item.ts       # Lambda: POST /items
│   ├── lib/
│   │   ├── s3-client.ts              # S3 client factory (LocalStack-aware)
│   │   ├── errors.ts                 # Typed error classification
│   │   └── config.ts                 # Environment config loader
│   └── scripts/
│       ├── upload.ts                 # Exercise 1: Upload JSON to S3
│       └── retrieve.ts              # Exercise 1: Retrieve JSON from S3
├── api/openapi.yaml                  # OpenAPI 3.0 spec
├── test/                             # Unit + integration tests
├── docker-compose.yml                # LocalStack container
├── vitest.config.ts                  # Unit test config
├── vitest.integration.config.ts      # Integration test config
└── Makefile                          # Convenience commands
```
